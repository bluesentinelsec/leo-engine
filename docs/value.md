# **Leo Engine Runtime — Value Proposition**

Leo Engine Runtime is built for **game developers who value speed, control, and simplicity**. From the moment you install to the moment your first sprite appears on screen, you never have to leave your terminal. Whether you’re building a retro-inspired 2D game, a pixel-perfect platformer, or an experimental prototype, Leo Engine provides the tools you need—without the overhead you don’t.

---

## **Core Values**

### 1. Programmer-First Workflow

* Install, bootstrap, run, debug, profile, and package—all from the terminal.
* No heavy IDE requirements. Perfect for developers who live in Vim, Emacs, or VS Code.
* First sprite on screen within minutes of install.

### 2. Git & CI/CD Friendly

* Fully source-controlled projects.
* Headless mode for CI testing.
* Deterministic replays for bug reproduction across platforms.

### 3. Lightweight but Capable

* SDL-like API, but with more built-in capability and fewer heavyweight dependencies.
* Includes battle-tested, static libraries:

  * **stb\_image** / **stb\_truetype** for images and fonts
    * **miniaudio** for cross-platform audio
    * No unnecessary bulk; just the essentials for a commercially competent game.

### 4. CLI for the Entire Development Cycle

* **pip install leo-cli**, run one command, and see a sprite.
* Create, run, debug, profile, and package your game without switching tools.
* Build to any supported platform from the same CLI command.

### 5. Broad Platform Support

* Windows AMD64
* macOS AMD64 and ARM64
* Linux AMD64
* Emscripten for instant web builds

### 6. Minimal Friction at Every Step

* Bootstrap → sprite → hot reload → debug → profile → ship.
* Common IDE integration without special configuration.
* Predictable, cross-platform behavior for rendering, timing, and input.

### 7. Low- and High-Level APIs

* **Low-level API**: Raylib-level abstraction—control without drowning in details.
* **High-level API**: Sane defaults and “just works” behavior for faster prototyping.

### 8. Level Building and World Design

* Code-first workflow with **Tiled** integration for maps and levels.
* Support for virtual resolutions, pixel-perfect graphics, and correct window scaling.

### 9. Asset Pipeline Built-In

* Pack, compress, and obfuscate assets into resource packs.
* Hot-reload assets while running.
* Protect assets from trivial copying without unrealistic DRM goals.

### 10. Extendable and Maintainable

* Minimal “batteries included” approach—just enough for an MVP game.
* Extend via simple plugin API without forking the engine.
* Add new functionality over time without bloat.

### 11. Debugging and Profiling Tools

* Built-in logging and profiling overlays.
* Hooks for custom logging and performance analysis.
* Optional memory safety checks and leak detection in debug builds.

### 12. Stable, Versioned API/ABI

* C API with stable ABI for long-term projects.
* Clear upgrade path between versions.

### 13. Small Footprint & Fast Startup

* Tiny binaries, minimal startup time—great for rapid iteration.
* Ideal for retro and pixel-art games.

### 14. Strong Documentation & Examples

* Examples for all major features, accessible from the terminal.
* Clear, concise documentation for getting started and going deep.

---

**Leo Engine Runtime exists to get you from concept to creation with minimal barriers, maximum control, and confidence that your game will run—and look—exactly the way you intended, everywhere it’s played.**

---

If you’d like, I can also make you a **shorter “elevator pitch”** version of this doc so you have both the long-form README-friendly one and a two-sentence marketing blurb. That way you can use one internally and one for quick outward communication. Would you like me to prepare that?

